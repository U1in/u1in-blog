# Javascript的new, _proto_, prototype

> 说到原型链，这三个家伙是逃不了的

说这三个之前，我们先说说Js的new这个操作符吧。

Js的new操作符执行三条命令

例如:

```js
var obj = new Myobject();
```

这条指令其实就相当于

```js
var obj = {} //创建一个空对象
obj.__proto__ = Myobject.prototype // 将新对象的__proto__ 指向 构造函数的prototype对象的内存地址
Myobject.call(obj);//以obj的上下文执行构造函数的内容
```
> call相关知识占坑

\_\_proto\_\_是一个隐藏的属性，所以有些浏览器甚至不会帮你补全这个属性，所以尽管手打，这个属性是的的确确存在的。而且它指向构造这个对象的构造函数的原型。

之前我们说过prototype是所有子类都实例化的时候都会引用的一个对象。至于为什么，看看上面的new，是不是把所有子类的\_\_proto\_\_都指向了构造函数原型的内存地址了。(所以要小心不要乱改子类的\_\_proto\_\_属性，估计这就是为什么浏览器都把它隐藏起来乱吧)

还是同一篇文章，我们说过，实例对象的属性和方法分为两种。一个是本地的，一个是引用的（也就是原型prototype上面的）。

为什么子类可以继承父类的属性方法呢？ 因为js在处理对象的属性方法的时候，会现在本地的属性方法上面找，若是找不到，则沿着\_\_proto\_\_指向的方向（也就是它的父类原型）里面找，如果还是找不到，就在这个父类的\_\_proto\_\_（也就是再上一级的原型）里面去找。这也就是所谓的原型链。

[![QQ20171123-212424@2x.png](https://i.loli.net/2017/11/23/5a16d3c670b40.png)](https://i.loli.net/2017/11/23/5a16d3c670b40.png)

所以new操作，其实就是在原型链的最底部，添加一个新的对象。

所以这三者的存在就是，\_\_proto\_\_必定是指向prototype的，new使得他们相等。

就像磁铁南极（\_\_proto\_\_）北极（prototype）必定会吸引，new把他们摆到了一起。
